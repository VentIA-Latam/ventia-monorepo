# == Schema Information
#
# Table name: messaging.messages
#
#  id                        :bigint           not null, primary key
#  content                   :text
#  message_type              :integer          not null
#  content_type              :integer          default("text")
#  status                    :integer          default("sent")
#  private                   :boolean          default(FALSE)
#  sender_type               :string
#  sender_id                 :bigint
#  source_id                 :string
#  content_attributes        :jsonb            default({})
#  additional_attributes     :jsonb            default({})
#  processed_message_content :text
#  account_id                :bigint           not null
#  inbox_id                  :bigint           not null
#  conversation_id           :bigint           not null
#  created_at                :datetime         not null
#  updated_at                :datetime         not null
#
# Indexes
#
#  index_messages_on_account_id        (account_id)
#  index_messages_on_conversation_id   (conversation_id)
#  index_messages_on_inbox_id          (inbox_id)
#  index_messages_on_sender            (sender_type, sender_id)
#  index_messages_on_source_id         (source_id)
#

class Message < ApplicationRecord
  include Wisper::Publisher

  MAX_CONTENT_LENGTH = 150_000

  # Virtual attribute to skip automatic send_reply callback (used when file upload handles it manually)
  attr_accessor :skip_send_reply

  # Validations
  validates :account_id, presence: true
  validates :inbox_id, presence: true
  validates :conversation_id, presence: true
  validates :message_type, presence: true
  validates :content_type, presence: true
  validates :content, length: { maximum: MAX_CONTENT_LENGTH }

  # Associations
  belongs_to :account
  belongs_to :inbox
  belongs_to :conversation
  belongs_to :sender, polymorphic: true, optional: true

  has_many :attachments, dependent: :destroy, autosave: true

  # Enums (hash syntax like Chatwoot to avoid method conflicts)
  enum message_type: { incoming: 0, outgoing: 1, activity: 2, template: 3 }
  enum content_type: {
    text: 0,
    input_text: 1,
    input_textarea: 2,
    input_email: 3,
    input_select: 4,
    cards: 5,
    form: 6,
    article: 7,
    incoming_email: 8,
    input_csat: 9,
    sticker: 10
  }
  enum status: { sent: 0, delivered: 1, read: 2, failed: 3 }

  # Store accessors
  store_accessor :content_attributes,
                 :template_params,
                 :in_reply_to,
                 :external_created_at,
                 :external_error

  # Callbacks
  before_save :ensure_processed_message_content
  after_create_commit :broadcast_created
  after_create_commit :send_reply
  after_create_commit :update_conversation_waiting_status
  after_update_commit :broadcast_updated, if: :saved_change_to_status?

  # Scopes (incoming/outgoing already generated by enum)
  scope :chat, -> { where.not(message_type: :activity).where(private: false) }
  scope :unread, -> { where.not(status: :read) }
  scope :recent, -> { order(created_at: :desc) }

  def inbound?
    incoming? || template?
  end

  def outbound?
    outgoing? && !private?
  end

  def webhook_data
    {
      id: id,
      content: content,
      message_type: message_type,
      content_type: content_type,
      status: status,
      created_at: created_at.to_i,
      conversation_id: conversation_id,
      ai_agent_enabled: conversation.ai_agent_enabled,
      sender: sender&.webhook_data,
      attachments: attachments.map(&:push_event_data)
    }
  end

  private

  def ensure_processed_message_content
    self.processed_message_content = content if processed_message_content.blank?
  end

  def send_reply
    return if skip_send_reply
    return unless outgoing? || template?
    return if private?

    if attachments.any?
      ::SendReplyJob.set(wait: 2.seconds).perform_later(id)
    else
      ::SendReplyJob.perform_later(id)
    end
  end

  def broadcast_created
    Rails.logger.info "[Event] Message #{id} created for conversation #{conversation_id}"
    broadcast(:message_created, data: { message: self })
  end

  def broadcast_updated
    Rails.logger.info "[Event] Message #{id} updated: status=#{status}"
    broadcast(:message_updated, data: { message: self, changed_attributes: saved_changes })
  end

  def update_conversation_waiting_status
    return if private?

    if incoming? && conversation.waiting_since.nil?
      conversation.update_column(:waiting_since, created_at)
    elsif (outgoing? || template?) && !private?
      if conversation.first_reply_created_at.nil?
        conversation.update_columns(first_reply_created_at: created_at, waiting_since: nil)
      else
        conversation.update_column(:waiting_since, nil)
      end
    end
  end
end
